package thredds.crawlabledataset.s3

import spock.lang.Specification

/**
 * Tests S3URI.
 *
 * @author cwardgar
 * @since 2015/08/26
 */
class S3URISpec extends Specification {
    def "constructor throws exception for invalid arguments"() {
        when: "no S3 prefix"
        new S3URI("/path/to/object")

        then:
        IllegalArgumentException e1 = thrown()
        e1.message == "S3 URI '/path/to/object' does not start with the expected prefix 's3://'."

        when: "null bucket"
        new S3URI(null, "foo")

        then:
        NullPointerException e2 = thrown()
        e2.message == "Bucket must be non-null."

        when: "bucket name length less than 3"
        new S3URI("be", "kind")

        then:
        IllegalArgumentException e3 = thrown()
        e3.message == "Bucket name 'be' must be at least 3 characters."

        when: "key can't be empty string, 1-arg ctor"
        new S3URI("s3://bucket/")

        then:
        IllegalArgumentException e4 = thrown()
        e4.message == "Key may not be the empty string."

        when: "key can't be empty string, 2-arg ctor"
        new S3URI("bucket", "")

        then:
        IllegalArgumentException e5 = thrown()
        e5.message == "Key may not be the empty string."

        when: "key can't contain consecutive delimiters"
        new S3URI("s3://bucket/one//two/three/")

        then:
        IllegalArgumentException e6 = thrown()
        e6.message == "Key 'one//two/three/' contains consecutive delimiters."
    }

    def "constructor allows null keys"() {
        expect: "1-arg ctor"
        new S3URI("s3://bucket").getKey() == null

        and: "2-arg ctor"
        new S3URI("bucket", null).getKey() == null
    }

    def "constructor removes trailing delimiter"() {
        expect:
        new S3URI("s3://bucket/key/").getKey() == "key"
        new S3URI("bucket", "some/other/key/").getKey() == "some/other/key"
    }

    def "getKeyWithTrailingDelimiter"() {
        expect:
        new S3URI("s3://bucket/key").getKeyWithTrailingDelimiter() == "key/"
        new S3URI("bucket", "key/").getKeyWithTrailingDelimiter() == "key/"
        new S3URI("s3://bucket").getKeyWithTrailingDelimiter() == null
    }

    def "getBaseName"() {
        expect:
        new S3URI("s3://bucket/some/very/long/key/name/yep!").getBaseName() == "yep!"
        new S3URI("bucket", null).getBaseName() == null
    }

    def "getParent"() {
        expect:
        new S3URI("s3://bucket/one/two/three").getParent() == new S3URI("s3://bucket/one/two")
        new S3URI("s3://bucket/no-parent").getParent() == new S3URI("s3://bucket")
        new S3URI("bucket", null).getParent() == null
    }

    def "getChild"() {
        expect: "success"
        new S3URI("s3://dogs/husky").getChild("") == new S3URI("s3://dogs/husky")
        new S3URI("s3://shire").getChild("frodo/baggins") == new S3URI("s3://shire/frodo/baggins")
        new S3URI("s3://hobbits/frodo/sam").getChild("merry/pippin") == new S3URI("s3://hobbits/frodo/sam/merry/pippin")

        // Failures
        when: "null relativePath"
        new S3URI("s3://shire").getChild(null)

        then:
        NullPointerException e1 = thrown()
        e1.message == "relativePath must be non-null."

        when: "absolute path"
        new S3URI("s3://shire/hobbiton").getChild("/rohan/edoras")

        then:
        IllegalArgumentException e2 = thrown()
        e2.message == "Path '/rohan/edoras' should be relative but begins with the delimiter string '/'."

        when: "consecutive delimiters"
        new S3URI("s3://shire/hobbiton").getChild("nasty//taters")

        then:
        IllegalArgumentException e4 = thrown()
        e4.message == "Key 'hobbiton/nasty//taters' contains consecutive delimiters."
    }

    def "toString test"() {
        expect:
        new S3URI("bucket", null).toString() == "s3://bucket"
        new S3URI("bucket", "one/two").toString() == "s3://bucket/one/two"
        new S3URI("s3://bucket/key/").toString() == "s3://bucket/key"
    }

    // equals() and hashCode() methods are simple and were auto-generated by IntelliJ, so they are very unlikely to
    // be correct. So, I'm not going to test them here. Besides, it's a pain in the ass to fully test the contract
    // of those two.
}
